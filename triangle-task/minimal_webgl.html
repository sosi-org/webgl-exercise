<!DOCTYPE html>
<html  lang="en">
<head>
    <title>WebGL example</title>
    <meta charset="utf-8" />
</head>
<body>
    <canvas id="glcanvas" width="640" height="480">
        Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
    </canvas>
    <!--img  src="./painting.gif"/-->
    <script>

    // based on https://github.com/waldyrious/minimal-webgl/blob/gh-pages/index.xhtml
    // texture from https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL

    window.onload = main;
    function main() {
        // Get the WebGL context from the canvas
        try { var gl = document.getElementById("glcanvas").getContext("webgl") } catch(ex) {}//02
        if (!gl) { console.log("Unable to initialize WebGL. Your browser may not support it."); return; }//03








        // Setup the shader program with the vertex shader and the fragment shader

        var shaderProgram = buildShaderProgram(gl,
            // The only attribute set for the vertices is the position. We could also set normals, color, texture, etc.
             // vertex shader:
            `
            attribute vec2 a_position;

            attribute vec2 aTextureCoord;
            varying highp vec2 vTextureCoord;

            void main() {
                // gl_Position = vec4(a_position, 0.0, 1.0);
                // gl_Position = uProjectionMatrix * uModelViewMatrix * (vec4(a_position, 0.0, 1.0));
                gl_Position =  (vec4(a_position, 0.0, 1.0));
                vTextureCoord = aTextureCoord;
            }
            ` ,


             // fragment shader:
            `
            precision mediump float;
            uniform vec3 u_color;

            varying highp vec2 vTextureCoord;
            uniform sampler2D uSampler;

            void main() {
                //gl_FragColor = vec4(u_color, 1.0);
                gl_FragColor = texture2D(uSampler, vTextureCoord);
            }
            `
        );



        //gl.useProgram(shaderProgram);

        var coordDimensions=2;
        var objColor=[0.333, 0.666, 0.999];
        var vertexCoords_array = new Float32Array([
            -0.5, -0.5,
             0.5, -0.5,
            -0.5,  0.5,
             //0.5,  0.5
        ]);


        const pinfo = {
          //program: shaderProgram,
          attribLocations: {
            vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
            textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord'),
          },
          uniformLocations: {
            //projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
            //modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
            uSampler: gl.getUniformLocation(shaderProgram, 'uSampler'),
          },
        };

        console.log(pinfo);



        const my_texture = loadTexture(gl, './painting.gif');


        //var textureCoordBuffer = texture__textureCoordBuffer(gl).textureCoordBuffer;
        const textureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
        const textureCoordinates = [
            // Front
            0.0,  0.0,
            1.0,  0.0,
            1.0,  1.0,
            0.0,  1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates),  gl.STATIC_DRAW);




/*
        var buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);// Set this buffer as the current one for the next buffer operations
        // Fill the buffer with the triangles.
        // STATIC_DRAW states that we are only going to write to this buffer very infrequently
        // so the system can optimise for this situation.
        // It doesn't stop us from writing to the buffer again,
        // but it might not be as efficient.
        // See http://stackoverflow.com/q/16462517 for more details.
        gl.bufferData(gl.ARRAY_BUFFER, vertexCoords_array, gl.STATIC_DRAW);
        // Get a reference to the "a_position" variable of the vertex shader,
        // which we'll connect with the 3D vertex data now stored in the current WebGL buffer.
        var sh_position = gl.getAttribLocation(shaderProgram, "a_position");
        // Enable the a_position vertex attribute for rendering
        // All client-side capabilities are disabled by default,
        // including all vertex attribute arrays.
        gl.enableVertexAttribArray(sh_position);
        // Specify the data structure of the array that will be used to store the vertex position data.
        // The parameters indicate that the vertexPos attribute is:
        // - a list of elements with 2 components each (2D vertices)
        // - of type gl.Float
        // - and they should be un-normalized.
        // The final two parameters are rarely used.
        // The first specifies the stride of the data i.e. the amount of storage allocated to each element
        // and the second specifies the offset i.e. where the data starts.
        // For standard JavaScript arrays both are set to zero to indicate tight packing and no offset.
        gl.vertexAttribPointer(sh_position, coordDimensions, gl.FLOAT, false, 0, 0);
        var sh_color = gl.getUniformLocation(shaderProgram, "u_color");
        gl.uniform3f(sh_color, objColor[0], objColor[1], objColor[2]);
*/
        //gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertexCoords_array.length/coordDimensions);
        gl.clearColor(0, 0, 0, 1); // defaults to white (1,1,1)
        gl.clear(gl.COLOR_BUFFER_BIT);



        //projectionMatrix

        /*  gl.uniformMatrix4fv(
              programInfo.uniformLocations.projectionMatrix,
              false,
              projectionMatrix);
          gl.uniformMatrix4fv(
              programInfo.uniformLocations.modelViewMatrix,
              false,
              modelViewMatrix);
        */


        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        const indices = [ 0,  1,  2,  ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);


        //texture_coords(gl, textureCoordBuffer, pinfo);
        const num = 2; // every coordinate composed of 2 values
        const type = gl.FLOAT; // the data in the buffer is 32 bit float
        const normalize = false; // don't normalize
        const stride = 0; // how many bytes to get from one set to the next
        const offset = 0; // how many bytes inside the buffer to start from
        gl.bindBuffer(gl.ARRAY_BUFFER, /*buffers.textureCoord*/ textureCoordBuffer);
        gl.vertexAttribPointer(pinfo.attribLocations.textureCoord, num, type, normalize, stride, offset);
        gl.enableVertexAttribArray(pinfo.attribLocations.textureCoord);


        gl.useProgram(shaderProgram);


        // Tell WebGL we want to affect texture unit 0
        gl.activeTexture(gl.TEXTURE0);
        // Bind the texture to texture unit 0
        gl.bindTexture(gl.TEXTURE_2D, my_texture);
        // Tell the shader we bound the texture to texture unit 0
        gl.uniform1i(pinfo.uniformLocations.uSampler, 0);

        {
          const vertexCount = 3; ////36;
          const type = gl.UNSIGNED_SHORT;
          const offset = 0;
          gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);
        }


    }

    function buildShader(gl, type, source) {
        var sh;
        if (type == "fragment")
            sh = gl.createShader(gl.FRAGMENT_SHADER);
        else if (type == "vertex")
            sh = gl.createShader(gl.VERTEX_SHADER);
        else // Unknown shader type
            return null;
        gl.shaderSource(sh, source);
        gl.compileShader(sh);
        // See if it compiled successfully
        if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
            console.log("An error occurred compiling the " + type +
            " shader: " + gl.getShaderInfoLog(sh));
            return null;
        } else { return sh; }
    };


    function buildShaderProgram(gl, vertShaderSrc, fragShaderSrc) {

        var prog = gl.createProgram();

        gl.attachShader(prog, buildShader(gl, 'vertex', vertShaderSrc) );
        gl.attachShader(prog, buildShader(gl, 'fragment', fragShaderSrc));

        gl.linkProgram(prog);

        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
            throw "Could not link the shader program!";
        }
        return prog;
    }

    function loadTexture(gl, url) {
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);

      const level = 0;
      const internalFormat = gl.RGBA;
      const width = 1;
      const height = 1;
      const border = 0;
      const srcFormat = gl.RGBA;
      const srcType = gl.UNSIGNED_BYTE;
      const pixel = new Uint8Array([0, 0, 255, 255]);  // opaque blue
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                    width, height, border, srcFormat, srcType,
                    pixel);

      const image = new Image();
      image.onload = function() {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                      srcFormat, srcType, image);

        if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
           gl.generateMipmap(gl.TEXTURE_2D);
        } else {
           // Turn off mip-mapping
           gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
           gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
           gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        }
      };
      image.src = url;

      return texture;
    }

    function texture__textureCoordBuffer(gl)
    {


          return {
            //position: positionBuffer,
            textureCoord: textureCoordBuffer,
            //indices: indexBuffer,
          };
    }

    /*
    function texture_coords(gl, textureCoordBuffer, pinfo)
    {
        const num = 2; // every coordinate composed of 2 values
        const type = gl.FLOAT; // the data in the buffer is 32 bit float
        const normalize = false; // don't normalize
        const stride = 0; // how many bytes to get from one set to the next
        const offset = 0; // how many bytes inside the buffer to start from
        gl.bindBuffer(gl.ARRAY_BUFFER,  textureCoordBuffer);
        gl.vertexAttribPointer(pinfo.attribLocations.textureCoord, num, type, normalize, stride, offset);
        gl.enableVertexAttribArray(pinfo.attribLocations.textureCoord);
    }
    */




    function isPowerOf2(value) {
      return (value & (value - 1)) == 0;
    }

    //function drawObject(gl, shaderProgram, coordDimensions, objColor, vertexCoords_array) {
    //}
    </script>
</body>
</html>
