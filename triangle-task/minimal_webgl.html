<!DOCTYPE html>
<html  lang="en">
<head>
    <title>Sohail's WebGL example</title>
    <meta charset="utf-8" />
</head>
<body>
    Texture preview: <img  src="./images/painting.gif" width=50 height=50/> <br/>
    WebGL Canvas:<br/>
    <canvas id="glcanvas" width="640" height="480">
        Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
    </canvas>
    <script type="text/javascript" src=triangle_painter.js></script>

    <script>
    'use strict;'

    // based on
    //      https://github.com/waldyrious/minimal-webgl/blob/gh-pages/index.xhtml
    // texture  code based on:
    //     https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL

    window.onload = main;


    var guy = new OpenglTrianglePainter();
    var global_gl = null;

    function init_gl() {
        // Get the WebGL context from the canvas
        try {
            var gl = document.getElementById("glcanvas").getContext("webgl");
        } catch(ex) {
            console.log("Unable to initialize WebGL. Your browser may not support it.");
            var gl = null;
            alert('Sorry, no WebGL');
        }

        return gl;
    }


    function main()
    {

        let gl = init_gl();
       guy.init_shaders(gl);

       global_gl = gl;

       var texture_ = load_texture(gl, './images/painting.gif');
       guy.texture = texture_;

       guy.brightnessBoost = [0., 0., 0.]; //[0.333/10, 0.666/10, 0.999/10];


       guy.triangle_vertices = new Float32Array([
           //2 x vertices. Like a queue.
           -0.3,  0.3,
           0.3,  0.2,
           0.1,  -0.1,
       ]);

       guy.texture_coords_array = new Float32Array([
                       0.0,  0.0,
                       1.0,  0.0,
                       1.0,  1.0,
                       0.0,  1.0,
                   ]);

        //guy.draw_everything(gl);
        guy.draw_textured_triangle(global_gl, guy.texture_coords_array, guy.triangle_vertices, guy.brightnessBoost, guy.texture);

        requestAnimationFrame(render);

    }

    function render_rate_limited(time) {
        //guy.triangle_vertices[0] += 0.002;
        guy.triangle_vertices[0] += (Math.random()*2-1)*0.002 + 0.0002;
        guy.triangle_vertices[1] += (Math.random()*2-1)*0.002;

        guy.brightnessBoost[0] = Math.sin(time*0.001 * Math.PI*2)*1 - 0.5;

        guy.texture_coords_array[1] = (Math.sin(time*0.001 * 1* Math.PI) +1) * 0.5;

        if (guy.brightnessBoost[0] < 0.) guy.brightnessBoost[0] = 0.
        //guy.draw_everything(guy.gl);
        guy.draw_textured_triangle(global_gl, guy.texture_coords_array, guy.triangle_vertices, guy.brightnessBoost, guy.texture);

    }

    var accum = 0;
    function render(now) {
        WAIT_MSEC = 10; //1000 / 4;
        if (now - accum > WAIT_MSEC) {
            //console.log("next frame", now);
            //accum = accum + 1000;
            //render_rate_limited(now);
            accum = now;
        }
        render_rate_limited(now);
        requestAnimationFrame(render);
    }
    function buildShader(gl, type, source) {
        var sh;
        if (type == "fragment")
            sh = gl.createShader(gl.FRAGMENT_SHADER);
        else if (type == "vertex")
            sh = gl.createShader(gl.VERTEX_SHADER);
        else // Unknown shader type
            return null;
        gl.shaderSource(sh, source);
        gl.compileShader(sh);
        // See if it compiled successfully
        if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
            console.log("An error occurred compiling the " + type +
            " shader: " + gl.getShaderInfoLog(sh));
            return null;
        } else { return sh; }
    };


    function buildShaderProgram(gl, vertShaderSrc, fragShaderSrc) {

        var prog = gl.createProgram();

        gl.attachShader(prog, buildShader(gl, 'vertex', vertShaderSrc) );
        gl.attachShader(prog, buildShader(gl, 'fragment', fragShaderSrc));

        gl.linkProgram(prog);

        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
            throw "Could not link the shader program!";
        }
        return prog;
    }


    function load_image(url, then)
    {
        const image = new Image();
        image.onload = function(){then(image);};
        image.src = url;
    }


    function load_texture(gl, url /*, callback2*/) {
        console.log(gl);

        const texture1 = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture1);

        const level = 0;
        const internalFormat = gl.RGBA;
        const width = 1;
        const height = 1;
        const border = 0;
        const srcFormat = gl.RGBA;
        const srcType = gl.UNSIGNED_BYTE;

        // What to show before the image is loaded
        const preview_single_pixel = new Uint8Array([0, 255, 0, 255]);  // green

        gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                      width, height, border, srcFormat, srcType,
                      preview_single_pixel);


        load_image(url, function(image) {

            gl.bindTexture(gl.TEXTURE_2D, texture1);
            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                    srcFormat, srcType, image);

            function isPowerOf2(value) {
                return (value & (value - 1)) == 0;
            }

            if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
               gl.generateMipmap(gl.TEXTURE_2D);
            } else {
               // Turn off mip-mapping
               gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
               gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
               gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            }
            console.log("Image loaded. Now:",url, texture1);

        });
        return texture1;
    }


    /*
    gl.deleteTexture(someTexture);
    gl.deleteTexture(someOtherTexture);
    gl.deleteBuffer(someBuffer);
    gl.deleteBuffer(someOtherBuffer);
    gl.deleteRenderbuffer(someRenderbuffer);
    gl.deleteFramebuffer(someFramebuffer);
    */


    </script>
</body>
</html>
